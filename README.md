# Silmaril

MUD-клиент для игры на сервере adan.ru с использованием кастомного протокола.

![Screenshot of the program](./docs/screenshot.png)

## Возможности
Помимо стандартных возможностей mud-клиентов (триггеры, алиасы), можно отметить:

* DSL-скрипты на Kotlin
* А* патфайндинг в любую зону/клетку мира
* Комбинированное отображение всех "окон" на карте
* Интеграция лоров в магазин, аукцион, рынок
* Два скина: классический и современный
* Кросс-платформенность (не нативная; через JVM)

## Установка
Если вы играли на AMC, вам понадобится перенести лоры и информацию об открытых клетках карты, а также ваши записи на картах.
1. Запустите программу.
2. В меню нажмите "Импортировать карты из AMC".
<img src="docs/img.png" alt="img" width="290">
3. Вручную перенесите лоры из `Documents\Adan client\Stuff` в `Documents\Silmaril\lores`

Проверьте, что перенесенные лоры работают, набрав **#lore хоббитский** или другой предмет.

> [!NOTE]  
> На macOS и linux, Silmaril будет пытаться стянуть карты из `~/Documents/Adan client/Maps/ZoneVizits`
> 
> Положите карты по этому пути перед импортированием.
> 
> Переносить лоры вам понадобится в путь `~/Documents/Silmaril/lores`

> [!TIP]  
> Лоры Silmaril – обратно-совместимы с AMC. Вы можете свободно переносить файлы туда и обратно.

## Новый функционал

### Карта
На карте видны все ваши окна:

<img src="docs/map1.png" alt="img" width="259">

В данном примере один из ваших персонажей – на севере от вас, а другой – на западе. 

Верхняя цифра рядом с клеткой указывает кол-во ваших согруппников в клетке. Нижняя – мобов.

Предупреждающая иконка указывает на то, что один из ваших персонажей – в бою.

Все этажи зон автоматически объединяются, например так выглядят пещеры гоблинов:

<img src="docs/map2.png" alt="img" width="893">

Кастомный цвет клетки, иконки и комментарии переносятся из АМС, но пока что нет возможности редактировать эту информацию.

Двойной клик по клетке включит бег к этой клетке.

Команда `#previewZone имя локации` откроет карту желаемой локации. Чтобы её выключить - переместитесь на любую соседнюю клетку.

### Поиск путей

В клиенте встроен поиск путей. Чтобы перейти в любую зону мира из любой клетки мира, наберите `#path имя зоны`. Новичкам это должно помочь с квестингом, а опытным игрокам сэкономить время на составлении спидвоков.
Также, можно набрать `#path айди комнаты`.

Чтобы выключить путь, наберите `#path -1`.

### HP

Виджет группы показывает ХП вместо процентов. Чтобы виджет узнал ваши хп, наберет "счет" в игре своими персонажами.

Чтобы видеть хп других согруппников, им нужно написать "сост". Для петов, напишите "животное".

<img src="docs/hp.png" alt="img" width="316">

### Интеграция лоров в аукцион/магазин/рынок
Предметы в этих системах превращены в кликабельные ссылки, открывающие подсказку с лором. Лоры берутся из вашей базы предметов. В дальнейшем планируется обращаться к телеграмм-боту.

<img src="docs/lores1.png" alt="img" width="802">

### Скины

По-умолчанию клиент стартует с современным скином и шрифтами. В нем немного улучшены цветовые решения, напр. до/после:
<img src="docs/colors1.png" alt="img" width="678">

Если вам необходим визуальный стиль AMC, вы можете его вернуть в меню `Цветовая Тема -> ClassicBlack`.
Также, для получения "старого" шрифта, выберите `Шрифт -> Consolas`.

### Логирование
В Silmaril логирование идет всегда. Игровые логи лежат в `Documents\Silmaril\logs` и хранятся вечно.
<br>Системные логи лежат в `C:\Users\username\.silmaril\logs` и хранятся не дольше 5 дней.

## Как пользоваться

#### Профиль
Концепт профиля в Сильмариле немного отличается от привычного. Здесь профиль - это только _**список**_ включенных групп и переменные.

Таким образом, в профиле "маг" и "прист" можно включить группу "кастер", получив общие триггеры/алиасы/хоткеи для всех кастеров.

Открывая новое окно, вам будет предложено создать профиль. Вы можете создавать и удалять профили сколько-угодно. При удалении профиля, все алиасы/триггеры/итп сохраняются в своих группах.

#### Группы
Создав профиль, включите интересующие вас группы командой:
```
#group enable {название группы} -- скобки опциональны для групп из 1 слова
```
Используйте **#groups**, чтобы посмотреть список включенных/доступных.

<img src="docs/groups.png" alt="img" width="347">

#### Триггеры

Есть две команды для создания триггеров: **#act** и **#grep**.

**#act** создаёт триггер, привычный для пользователей AMC и JMC, с возможностью вставлять (^) в начало и ($) в конец, а также использовать паттерны типа (%0).

Синтаксис:

```
#act {условие} {команда} {приоритет} {название группы} -- приоритет и группа опциональны
```
> [!IMPORTANT]  
> При неуказании группы, триггер будет записан в группу SESSION. Эта группа уникальна тем, что она:
> 1. Не сохраняется.
> 2. Существует не для всех профилей, а только для одного.
> 
> Неуказание группы говорит о том, что это временный триггер!

Пример использования:
```
#act {^Там было %0 мон%2.} {разделить %0} {финансы}
```

> [!NOTE]  
> Учтите, что добавив триггер, например, в группу "кастер", все остальные окна с включенной группой "кастер" также сразу получат новый триггер.

**#grep** создает точно такой же триггер, но с регексом. При этом, в "действии" также можно использовать %0, %1 для групп, которые будут захвачены регексом.
Например:
```
#grep {^Там было (\d+) мон(.*)} {разделить %1} {финансы}
```

> [!CAUTION]
> Обратите внимание на %1 в примере. Если в **#act** можно было указывать паттерны с любыми цифрами и мэтчить эти же цифры, то в **#grep** группы идут по порядку, а паттерн %0 соответствует ВСЕЙ строке. Поэтому в данном примере для разделения суммы берется паттерн %1, а не %0.
> 
> Для избежания путаницы, пользвателю рекомендуется использовать паттерны начиная с %1, т.к. %0 зарезервинован для всей строки в случае с регексами.

Посмотреть существующие триггеры можно командой **#triggers** или **#triggers {название группы}**.

Чтобы удалить триггер, используйте **#unact** или **#ungrep** и полную строчку триггера, отображаемую в #triggers.
Планируется упростить процедуру удаления, т.к. на практике она оказалась не очень удобной.

### Алиасы
Синтаксис:
```
#al {сокращение} {полная команда} {приоритет} {группа} -- последние два параметра опциональны
```
Как и в случае с триггерами, неуказанная группа создаст алиас в группу SESSION и он не будет сохранен.

В отличие от AMC, возможно использовать алиас из нескольких слов, например:
```
#al {гоу} {#path} {пути} -- это создаст алиас с дефолтным приоритетом 5
```

```
#al {гоу мм} {гоу минас-моргул} {4} {пути} -- это создаст алиас с приоритетом 4
```

Таким образом "гоу мм" сначала будет заменен на "гоу минас-моргул", а затем на "#path минас-моргул".

В алиасе можно использовать паттерны %1, %2 итп.

Если вы НЕ УКАЗАЛИ паттернов, то автоматически добавляется паттерн %0 в конце

Таким образом, данные алиасы равносильны:
```
#al {у} {убить}
#al {у} {убить %0}
#al {у %0} {убить %0}
#al {у %0} {убить}
```

Использование нескольких паттернов дает возможность написания нестандартных алиасов:
```
#al {рем %0 %1} {чинить %0;чинить %1}
#al {д %0 %1} {дать %0 %1}
```

Посмотреть существующие алиасы можно командой **#aliases** или **#aliases {название группы}**.

Удаление через **#unalias** или **#unal**.

## Переменные
Установка переменной:
```
#var {название переменной} {значение переменной}
```
Прочтение переменной:
```
$название
```

В отличие от всех остальных видов объектов (триггеры, алиасы и т.п.), переменные существуют в профиле, а не в группе.

Переменные разрешаются в свое значение во всех контекстах, кроме когда они находятся в команде #act, #alias и т.п.
Таким образом, они будут записаны в алиас в виде `$переменной`, а не в виде закешированного значения.

Пример использования:
```
#var {ц1} {отшельник}
#al {атак} {подлость $ц1;поднож $ц1;закол $ц1} -- будет атаковать настоящее значение переменной
```

Посмотреть переменные можно командой **#vars**:

<img src="docs/variables.png" alt="img" width="371">

Удалить переменную можно командой **#unvar**

### Замены

```
#sub {изначальная строка} {желаемая строка} {приоритет} {группа}
```
Последние два параметра опциональны.
<br>Снова, как и прежде, неуказание группы сделает замену временной.

В желаемой строке можно указывать следующие тэги: \<size\> и \<color\>
Size имеет значения: small, medium, large. Примеры использования тэгов:

```html
#echo <size=small>00:01:20</size> <size=medium>текст</size> <size=large>что-то важное</size>
```

Тэг \<color\> имеет два параметра fg (foreground color) и bg (background color). Второй является опциональным.
Пример:
```html
#echo <color fg=dark-magenta>текст</color>
#echo <color fg=magenta bg=white>текст</color>
```

Вы можете использовать как привычные 16 цветов из мада, так и hex-значения.

Цвета мада будут слегка отличаться в зависимости от текущего скина.

Представлены значения: black, red, green, yellow, blue, magenta, cyan, white, none.
</br>Затем dark-black, dark-red, и т.п:

<img src="docs/colors.png" alt="img" width="467">

Для использования hex-значений, их следует брать в кавычки и начинать с (#). Пример:
```html
#echo <color fg="#a7ff35">салатовый текст</color>
```

Пример использования:
```
#sub {^Вы чувствуете здесь покой и умиротворенность.} {<color=green>%0</color>} {5} {ОБЩЕЕ}
```

В условии можно использовать паттерны, начиная с %1. В выводе, %0 является **всей строкой**, а %1 и далее являются матчингом паттернов из левой части.

Таким образом, команда **#sub**, помимо замен, также заменяет собой команду подсветки строк.

Если оставить в выводе только один пробел `{ }`, то команда проглотит строку и не выведет её. Таким образом, вы получаете функционал, известный как #gag в JMC.

Команда **#subs** или **#subs {группа}** напечатает все замены.

Удаление происходит командой **#unsub**.

Есть Regex-версия данной команды - **#subreg**. Удаление **#unsubreg**.

> [!TIP]  
> Есть встроенная переменная $time, отображающая время в формате HH:mm:ss

### Хоткеи
Синтаксис:
```
#hotkey {комбинация клавиш} {команда} {приоритет} {группа} -- последние два параметра опциональны
```

Пример:
```
Hotkey: {F1} {#window друид} {5} {ОБЩЕЕ}
Hotkey: {F2} {#window воин} {5} {ОБЩЕЕ}
Hotkey: {F3} {#window вор} {5} {ОБЩЕЕ}
Hotkey: {F4} {#window лучник} {5} {ОБЩЕЕ}
#hotkey {Shift+F12} {возврат} {общее}
```

Все возможные значения перечислены в файле [Hotkeys.kt](src/main/kotlin/ru/adan/silmaril/misc/Hotkeys.kt):

https://github.com/CodeSpartan/Silmaril/blob/982d396c23676ad047ea3f37aae71bcfd19b126c/src/main/kotlin/ru/adan/silmaril/misc/Hotkeys.kt#L48-L73

Отобразить текущие хоткеи можно командой **#hotkeys**.

Удаление – командой **#unhot**.

### Echo и Out
Команда **#echo** выведет текст так, будто он пришел от мада. На строку сработают триггеры, сабституты и пр.
Команда **#out** выведет текст в дополнительное окно.
Пример:
```
#echo <color=green>любой текст</color>
```
### Команды работы с окнами
```
#sendAll команда -- отправляет команду во все открытые окна.
#send {окно} {команда} -- отправляет команду в конкретное окно.
#sendId {айди} {команда} -- отправляет команду в N-ное окно. Окна отсчитываются от единицы.
```
Например `#sendId {1} {команда}` отправляет команду в первое окно.

```
#window {название профиля} -- переключает текущее окно. Скобки опциональны.
```

### Лоры
```
#lore название предмета -- отображает лор.
#comment текст -- делает заметку к ПОСЛЕДНЕМУ отображенному лору.
```

### Прочие команды
```
#conn сервер порт -- подключиться к серверу.
#zap -- разорвать связь с сервером.
```
Поддерживаются мады, не отсылающие GA.

```
#previewZone название зоны -- откроет зону на карте.
#path название зоны или клетки -- найдет путь и поведет вас в зону или клетку.
```
Более подробно описаны в разделе [карты](#карта).

```
#zones уровень -- напечатает зоны для уровня.
```
То же самое, что команда "зоны" в игре, но в отличие от мадовской команды, может отображать зоны для 0 уровня.

## DSL-скрипты
Вместо использования стандартных команд #act и пр., вы можете писать скрипты на Котлине. Это весьма удобно и экспрессивно.
В папке `Documents\Silmaril\dsl` создайте файл с расширением .mud.kts, например **Misc.mud.kts**, запишите в него скрипты, перезапустите клиент и не забудьте активировать группу Misc в клиенте – **#group enable misc**.

Чтобы написать триггер, подобный обычной команде #grep, используйте глагол grep:
```kts
"""^Там было (\d+) монет.?\.$""" grep { match ->
    // match[0] это полная строка
    // match[1] это первая группа
    var amount = (match[1]!!.toInt() * 0.8f).toInt()
    send("раздел $amount")
}
```
Данный скрипт удерживает 20% себе, а остальные 80% делит между согруппниками.

Другой пример:
```kts
"""^Вы слишком устали.$""" act {
    if (!isCurrentWindow())
        out("<color=cyan>${getProfileName()}: устал</color>")
}
```
При уставании не-текущего окна, будет писать "Прист: устал" в окно дополнительного вывода.

Вводными точками в скрипт являются глаголы. Названия глаголов соответствуют названиям команд. Их немного: **act**, **grep**, **alias** (нет регекс-варианта), **sub**, **subReg**.
Все из них имеют два варианта второго параметра: ламбду (как на примерах выше) или строка.

Например, два следующих триггера делают одно и то же:
```kts
"""^Мардорк пришел с востока.""" act "мах мардорк"

"""^Мардорк пришел с востока.""" act {
    send("мах мардорк")
}
```

У всех ламбд есть опциональный параметр, показанный ниже. Данные триггеры делают одно и то же:
```kts
"""%1 пришел с востока""" act "убить %1"

"""%1 пришел с востока""" act { match ->
    send("убить ${match[1]}")
}
```

Как вы уже заметили, помимо глаголов, которые запускают скрипт, есть API, которое можно вызывать в скриптах.

```kts
fun send(command: String)
fun echo(message: String, color: AnsiColor = AnsiColor.None, isBright: Boolean = false)
fun sendAll(command: String)
fun send(window: String, command: String)
fun sendId(windowId: Int, command: String)
fun getVar(varName: String): Variable?
// у Variable есть extension-методы:
variable.StringValue
variable.IntValue
variable.FloatValue
fun setVar(varName: String, varValue: Any) // принимает параметры Int, Float, String
fun unVar(varName: String)
fun window(windowName: String) // переключает окно
fun isCurrentWindow(): Boolean // активное ли окно у этого профиля?
fun out(message: String)
fun getProfileName(): String // как зовут этот профиль
fun formattedTime(): String // возвращает время в маленьком шрифте, удобно для окна вывода
```

DSL-скрипты всегда имеют приоритет 5.

Использование `getVar` и `setVat` имеет смысл, если этим переменным нужно пережить перезапуск клиента.
Для временных переменных, просто декларируйте их в котлине, вне скрипта.

Приведу пример скрипта (с использованием глагола alias), который получает все квесты в заданном диапазоне уровней, напр. команда "квест 10" получит все квесты 10 уровня, а "квест 10-15" – все квесты от 10 до 15.
```kts
/** Quests */
// функция помогающая вычленить диапазон целых чисел из команды "квест 10-15"
fun getIntSetFromString(input: String): Set<Int> {
    val regex = """(\d+)(?:-(\d+))?""".toRegex()
    val matchResult = regex.find(input)

    if (matchResult != null) {
        val firstNum = matchResult.groupValues[1].toInt()
        val secondNum = matchResult.groupValues[2].ifEmpty { null }?.toInt()

        return if (secondNum != null) {
            (firstNum..secondNum).toSet()
        } else {
            setOf(firstNum)
        }
    }

    return emptySet()
}

// Временные переменные мы декларируем прямо здесь.
// В wantQuestLevels мы сложим все уровни квестов, которые нас интересуют.
var wantQuestLevels: Set<Int> = setOf()
var collectQuests = false
"""квест %0""" alias { groups ->
    val input = groups[0].toString()
    wantQuestLevels = getIntSetFromString(input)
    collectQuests = true
    send("список")
    // Обратите внимание на асинк-код. Мы легко задаем что нужно выполнить через 2.5 секунды в скрипте.
    backgroundScope.launch {
        delay(2500)
        collectQuests = false
    }
}

// Не очень читабельный регекс, реагирующий на строки квестов, выпадающие по команде "список"
// Реагирует на [!] айди_квеста уровень_квеста
"""\[!\]\s+(\d+)\s+(\d+).*""" grep { match ->
    if (!collectQuests) return@grep
    var questId = match[1]?.toIntOrNull()
    var questLevel = match[2]?.toIntOrNull()
    // Если уровень нас удовлетворяет, получим этот квест
    if (wantQuestLevels.contains(questLevel))
        send("получить $questId")
}

// Прекращаем собирать квесты либо при получении данной строки, 
// либо через 2.5 сек после начала (т.к. эта строка не всегда приходит)
"""^Показаны только первые \d+ задан(.*)""" grep { collectQuests = false }
```

Таким образом, очень простой скрипт, написанный LLM, легко выполнит то, что обычными скриптами добиться нельзя, т.к. в клиенте нет #math.

При написании DSL-скриптов, вы можете получать подсветку и подсказки, если скомпилируете проект в IDE.

## Компиляция

> [!TIP]
> Этот раздел – для разработчиков.
 
Программа написана на Kotlin Compose, в большинстве кода использует Material. Однако для кастомного тайтл бара, был использован [Jewel](https://github.com/JetBrains/intellij-community/tree/master/platform/jewel). 

> [!IMPORTANT]
> Из-за Jewel, компиляция возможна только на [JBR](https://github.com/JetBrains/JetBrainsRuntime/releases) (21.0.8), т.к. обычная JDK не экспоузит манипуляцию тайтл-баром.

> [!IMPORTANT]
> DSL-скрипты корректно распознаются только в [IntelliJ IDEA 2025.1.4.1 (Ultimate Edition)](https://www.jetbrains.com/idea/download/other.html)

Автор не является экспертом в Kotlin, поэтому некоторые инструкции могут быть необязательными. 

*   Установите [JBR](https://github.com/JetBrains/JetBrainsRuntime/releases), чтобы `where java` в консоли указывала на JBR.
*   Откройте проект в [IntelliJ IDEA](https://www.jetbrains.com/idea/download/other.html)
*   После инициализации gradle, запустите gradle-таск `generateResourceAccessorsForMain` (меню gradle находится с правой стороны IDE)
*   Используйте таск `run` для запуска в IDE; таск `createReleaseDistributable` для портабельной сборки.

Опционально:
*   Чтобы IDE корректно работала с DSL скриптами, зайдите в File -> Settings -> Editor -> Languages & Framework -> Kotlin -> Kotlin Scripting и нажмите **Scan Classpath**. После перезапуска, в списке должен появиться MudScriptHost (.mud.kts). Отсортируйте его, чтобы он стал предпоследним в списке.
*   Сделайте junction `mklink /J "<путь к проекту>\src\main\resources\dsl" "C:\Users\<имя пользователя>\Documents\Silmaril\dsl"`. Таким образом, DSL-скрипты будут как будто лежать в проекте, получая авто-комплит и подсветку синтаксиса в IDE.

### Знакомство с кодовой базой
* Проект использует архитектуру MVVM, поэтому почти все Composable лежат в папке `view`, модели в `model`, а прокладки между ними в `viewmodel`.
* Используется библиотека Koin для Dependency Injection. Все factory лежат в `Modules.kt`
* Логирование настраивается в `\src\main\resources\logback.xml` - это библиотека logback.
* Каждое игровое окно - это модель `Profile`. У него есть свой `MudConnection`, `ScriptingEngine`, `MainViewModel`, `MapViewModel`, `GroupModel`, `MobsModel`, т.е. все модели, принадлежащие одному персонажу.
* В `Main` создаются окна `MainWindow`, `MapWindow`, `GroupWindow`, `MobsWindow`, `OutputWindow`, а при переключении окна, в них скармливается другой `Profile`.
* Код еще не очень хорошо рефакторнут, напр. есть god-class `Profile`, который следовало бы разобрать. Там сейчас обрабатываются все текстовые команды, вместо отдельного менеджера.